<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Eggshot</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; touch-action: none; }
        
        /* Video Background */
        #camera-video {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; z-index: 1; filter: brightness(0.9); /* Slightly darken video to make game pop */
        }

        /* Game Layer */
        #game-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2;
        }

        /* UI */
        #ui {
            position: absolute; top: 20px; left: 20px; z-index: 3;
            color: white; font-size: 20px; font-weight: 900;
            text-shadow: 2px 2px 0px #000; pointer-events: none;
        }
        .score-big { font-size: 40px; color: #ffeb3b; }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 4; color: white; background: rgba(0,0,0,0.8);
            padding: 20px; border-radius: 10px; text-align: center;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
</head>
<body>

    <video id="camera-video" autoplay playsinline muted></video>
    <canvas id="game-canvas"></canvas>
    
    <div id="ui">
        SCORE<br>
        <span id="score-val" class="score-big">0</span>
    </div>

    <div id="loading">Initializing Camera & AI...</div>

<script>
    // --- CONFIG ---
    const SETTINGS = {
        aiInterval: 150,    // AI checks every 150ms
        gravity: 1.2,       // Slightly higher gravity for realism
        bandStiffness: 0.1, // Elasticity (Lower is looser, but we use high velocity fix)
        shotPower: 18,      // Force multiplier on release
        maxStretch: 150     // How far you can pull back
    };

    // --- STATE ---
    let engine, world, render;
    let egg, anchor, elastic;
    let mouseConstraint;
    let score = 0;
    let targets = []; // AI detections
    let splats = [];  // Array to hold splat visual objects
    let isDragging = false;
    let canvas, ctx, video;
    
    // --- ASSETS (Procedural Drawing Helpers) ---
    const Draw = {
        egg: (x, y, radius, ctx) => {
            ctx.beginPath();
            ctx.ellipse(x, y, radius * 0.8, radius, 0, 0, Math.PI * 2);
            // Gradient for 3D look
            let grad = ctx.createRadialGradient(x - 5, y - 5, 2, x, y, radius);
            grad.addColorStop(0, "#fff");
            grad.addColorStop(1, "#e0e0e0");
            ctx.fillStyle = grad;
            ctx.fill();
            ctx.lineWidth = 1;
            ctx.strokeStyle = "#ccc";
            ctx.stroke();
        },
        woodTexture: (ctx) => {
            // Simple brown color for handle
            ctx.fillStyle = "#8B4513";
            ctx.strokeStyle = "#5D2906";
        },
        splat: (s, ctx) => {
            ctx.globalAlpha = s.opacity;
            ctx.fillStyle = "#FFD700"; // Yolk yellow
            ctx.beginPath();
            // Draw a messy blob
            ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
            ctx.arc(s.x + s.size*0.5, s.y - s.size*0.4, s.size*0.6, 0, Math.PI * 2);
            ctx.arc(s.x - s.size*0.4, s.y + s.size*0.3, s.size*0.7, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner white shine
            ctx.fillStyle = "rgba(255,255,255,0.6)";
            ctx.beginPath();
            ctx.arc(s.x - 5, s.y - 5, s.size * 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    };

    // --- INIT ---
    window.onload = async () => {
        video = document.getElementById('camera-video');
        canvas = document.getElementById('game-canvas');
        ctx = canvas.getContext('2d');

        resize();
        window.addEventListener('resize', resize);

        // 1. Camera
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: 'environment' } 
            });
            video.srcObject = stream;
            await new Promise(r => video.onloadedmetadata = r);
        } catch (e) { alert("Camera failed: " + e); }

        // 2. Physics
        initPhysics();

        // 3. AI
        initAI();

        // 4. Start Game Loop
        requestAnimationFrame(loop);
    };

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    // --- PHYSICS SETUP ---
    function initPhysics() {
        const { Engine, World, Bodies, Constraint, Mouse, MouseConstraint, Vector, Body } = Matter;
        engine = Engine.create();
        world = engine.world;
        engine.gravity.y = SETTINGS.gravity;

        // Anchor Point (Bottom Center)
        const aX = window.innerWidth / 2;
        const aY = window.innerHeight - 100;

        anchor = Bodies.circle(aX, aY, 5, { isStatic: true, render: { visible: false } });
        
        // The Egg
        egg = Bodies.circle(aX, aY - 20, 20, { 
            restitution: 0.6, 
            density: 0.005, // Heavy enough to fly true
            frictionAir: 0.01 // Low drag
        });

        // The Elastic
        elastic = Constraint.create({
            pointA: { x: aX, y: aY },
            bodyB: egg,
            stiffness: SETTINGS.bandStiffness,
            damping: 0.05,
            length: 1
        });

        World.add(world, [anchor, egg, elastic]);

        // Interaction
        const mouse = Mouse.create(canvas);
        mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: { stiffness: 0.2, render: { visible: false } }
        });
        
        // Hook into drag events
        Matter.Events.on(mouseConstraint, 'startdrag', () => { isDragging = true; });
        Matter.Events.on(mouseConstraint, 'enddrag', () => { 
            isDragging = false; 
            fireEgg();
        });

        World.add(world, mouseConstraint);
    }

    function fireEgg() {
        // Boost velocity manually for that "Snap" feel
        // Calculate vector from anchor to egg
        const forceVector = Matter.Vector.sub(anchor.position, egg.position);
        
        // If pulled back enough
        if (Matter.Vector.magnitude(forceVector) > 20) {
            // Detach elastic
            elastic.bodyB = null;
            
            // Apply HUGE force in the direction of the aim
            // We want it to go opposite to the drag (towards top of screen)
            const dir = Matter.Vector.normalise(forceVector);
            const force = SETTINGS.shotPower * egg.mass; 
            
            Matter.Body.applyForce(egg, egg.position, { 
                x: dir.x * force * 0.002, 
                y: dir.y * force * 0.002 
            });
        }
    }

    // --- AI SETUP ---
    async function initAI() {
        const model = await cocoSsd.load();
        document.getElementById('loading').style.display = 'none';

        setInterval(async () => {
            if (video.readyState === 4) {
                const predictions = await model.detect(video);
                // Just store the data, don't draw boxes
                targets = predictions.filter(p => p.class === 'person');
            }
        }, SETTINGS.aiInterval);
    }

    // --- MAIN RENDER LOOP ---
    function loop() {
        requestAnimationFrame(loop);
        
        // Physics Step
        Matter.Engine.update(engine, 1000 / 60);
        
        // Clear Screen
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 1. Draw Splats (Behind everything)
        updateAndDrawSplats();

        // 2. Draw Slingshot Bands (Back part)
        drawBands('back');

        // 3. Draw Egg
        // If egg is off screen, reset
        if (egg.position.y > canvas.height + 100 || egg.position.y < -500 || egg.position.x < -100 || egg.position.x > canvas.width + 100) {
            resetEgg();
        }
        Draw.egg(egg.position.x, egg.position.y, 20, ctx);

        // 4. Draw Slingshot Handle & Front Bands
        drawSlingshotHandle();
        drawBands('front');

        // 5. Logic
        checkCollisions();
    }

    // --- DRAWING HELPERS ---
    function drawSlingshotHandle() {
        const cx = window.innerWidth / 2;
        const cy = window.innerHeight; // Bottom of screen
        
        ctx.save();
        Draw.woodTexture(ctx);
        ctx.lineWidth = 15;
        ctx.lineCap = "round";
        
        // The "Y" shape
        ctx.beginPath();
        ctx.moveTo(cx, cy); // Base
        ctx.lineTo(cx, cy - 80); // Trunk
        ctx.stroke();
        
        // Left arm
        ctx.beginPath();
        ctx.moveTo(cx, cy - 80);
        ctx.lineTo(cx - 40, cy - 140);
        ctx.stroke();

        // Right arm
        ctx.beginPath();
        ctx.moveTo(cx, cy - 80);
        ctx.lineTo(cx + 40, cy - 140);
        ctx.stroke();
        ctx.restore();
    }

    function drawBands(layer) {
        // Don't draw bands if fired
        if (!elastic.bodyB) return;

        const cx = window.innerWidth / 2;
        const cy = window.innerHeight;
        const leftTip = { x: cx - 40, y: cy - 140 };
        const rightTip = { x: cx + 40, y: cy - 140 };

        ctx.lineWidth = 6;
        ctx.strokeStyle = "#333"; // Dark rubber
        ctx.beginPath();

        if (layer === 'back') {
            // Draw connect to left tip
            ctx.moveTo(leftTip.x, leftTip.y);
            ctx.lineTo(egg.position.x, egg.position.y);
        } else {
            // Draw connect to right tip
            ctx.moveTo(rightTip.x, rightTip.y);
            ctx.lineTo(egg.position.x, egg.position.y);
        }
        ctx.stroke();
    }

    function updateAndDrawSplats() {
        for (let i = splats.length - 1; i >= 0; i--) {
            let s = splats[i];
            Draw.splat(s, ctx);
            s.opacity -= 0.01; // Fade out
            s.size += 0.2;     // Expand slightly (drip)
            
            if (s.opacity <= 0) splats.splice(i, 1);
        }
    }

    // --- LOGIC ---
    function checkCollisions() {
        // Only check if egg is flying freely (not being dragged)
        if (elastic.bodyB) return; 

        // Scale factors
        const sx = canvas.width / video.videoWidth;
        const sy = canvas.height / video.videoHeight;

        for (let t of targets) {
            // Bounding box mapping
            let tx = t.bbox[0] * sx;
            let ty = t.bbox[1] * sy;
            let tw = t.bbox[2] * sx;
            let th = t.bbox[3] * sy;

            // Simple point collision (is egg center inside box?)
            if (egg.position.x > tx && egg.position.x < tx + tw &&
                egg.position.y > ty && egg.position.y < ty + th) {
                
                createSplat(egg.position.x, egg.position.y);
                score += 10;
                document.getElementById('score-val').innerText = score;
                
                // Reset egg immediately
                resetEgg();
                break;
            }
        }
    }

    function createSplat(x, y) {
        splats.push({
            x: x,
            y: y,
            size: 30 + Math.random() * 20,
            opacity: 1.0
        });
    }

    function resetEgg() {
        Matter.World.remove(world, egg);
        
        const aX = window.innerWidth / 2;
        const aY = window.innerHeight - 100;

        egg = Matter.Bodies.circle(aX, aY - 20, 20, { 
            restitution: 0.6, density: 0.005, frictionAir: 0.01 
        });

        // Reattach
        elastic.bodyB = egg;
        Matter.World.add(world, egg);
    }

</script>
</body>
</html>