<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Slingshot AR: MID-ANCHOR</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Arial Black', sans-serif; touch-action: none; }
        
        #camera-feed {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; z-index: 1; filter: contrast(1.1) brightness(0.8);
        }

        #game-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2;
        }

        /* HUD */
        #hud {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;
        }
        
        .score-container {
            position: absolute; top: 30px; left: 20px;
            text-shadow: 0px 4px 10px rgba(0,0,0,0.8);
        }
        
        .score-label { color: #f1c40f; font-size: 14px; letter-spacing: 2px; }
        .score-val { color: #fff; font-size: 48px; line-height: 1; }

        #crosshair {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 60px; height: 60px; border: 2px solid rgba(255, 255, 255, 0.5); border-radius: 50%;
            pointer-events: none; opacity: 0.8;
        }
        #crosshair::after {
            content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 4px; height: 4px; background: red; border-radius: 50%;
        }

        #status-msg {
            position: absolute; top: 70%; left: 50%; transform: translate(-50%, -50%);
            color: rgba(255,255,255,0.8); font-size: 14px; text-transform: uppercase; letter-spacing: 1px;
            text-align: center; width: 100%;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
</head>
<body>

    <video id="camera-feed" autoplay playsinline muted></video>
    <canvas id="game-layer"></canvas>
    
    <div id="hud">
        <div class="score-container">
            <div class="score-label">HITS</div>
            <div class="score-val" id="score">0</div>
        </div>
        <div id="crosshair"></div>
        <div id="status-msg">Loading AI...</div>
    </div>

<script>

// --- CONFIG ---
const CONFIG = {
    anchorHeightRatio: 0.5, // 0.5 = Middle of screen
    gravity: 1.5,
    launchForce: 0.28,      // Force Multiplier
    maxStretch: 350,        // How far back you can pull (increased!)
    shakeIntensity: 15
};

// --- GLOBALS ---
let engine, world;
let canvas, ctx, video;
let eggBody;
let isDragging = false;
let dragStart = { x: 0, y: 0 };
let currentDrag = { x: 0, y: 0 };
let targets = [];
let particles = [];
let score = 0;
let shake = 0;

// --- INIT ---
window.onload = async () => {
    canvas = document.getElementById('game-layer');
    ctx = canvas.getContext('2d');
    video = document.getElementById('camera-feed');
    
    resize();
    window.addEventListener('resize', resize);

    setupPhysics();

    try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
        video.srcObject = stream;
        video.onloadedmetadata = () => { initAI(); };
    } catch(e) { console.error(e); }

    requestAnimationFrame(renderLoop);
};

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}

// --- PHYSICS ---
function setupPhysics() {
    const { Engine, World, Mouse, MouseConstraint } = Matter;
    engine = Engine.create();
    world = engine.world;
    engine.gravity.y = CONFIG.gravity;

    const mouse = Mouse.create(canvas);
    const mc = MouseConstraint.create(engine, {
        mouse: mouse,
        constraint: { stiffness: 0.1, render: { visible: false } }
    });
    
    Matter.Events.on(mc, 'mousedown', (e) => {
        // Allow grabbing anywhere in the bottom half
        if (!eggBody && e.mouse.position.y > window.innerHeight * 0.4) {
            isDragging = true;
            // The "Virtual" anchor is the bottom center for calculation purposes
            dragStart = { x: window.innerWidth/2, y: window.innerHeight * 0.8 };
            currentDrag = { x: e.mouse.position.x, y: e.mouse.position.y };
        }
    });

    Matter.Events.on(mc, 'mousemove', (e) => {
        if (isDragging) currentDrag = e.mouse.position;
    });

    Matter.Events.on(mc, 'mouseup', (e) => {
        if (isDragging) {
            isDragging = false;
            fireEgg();
        }
    });

    World.add(world, mc);
}

function fireEgg() {
    const anchorY = window.innerHeight * CONFIG.anchorHeightRatio;
    const centerX = window.innerWidth / 2;
    
    // Vector from drag point to the "Anchor Plane"
    let dx = centerX - currentDrag.x;
    let dy = anchorY - currentDrag.y; 
    
    // We want to shoot "forward" (up the screen)
    // So if I pull down, dy is negative, but force should be positive (up)
    
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < 40) return; // Too weak

    const { Bodies, World, Body } = Matter;
    
    if (eggBody) World.remove(world, eggBody);

    eggBody = Bodies.circle(currentDrag.x, currentDrag.y, 15, {
        restitution: 0.5, density: 0.05, frictionAir: 0.005, label: "Egg"
    });

    World.add(world, eggBody);

    // Calculate Angle: From Pull Point -> Center Screen Target
    const angle = Math.atan2(anchorY - currentDrag.y, centerX - currentDrag.x);
    
    // Apply Force
    const force = Math.min(dist, CONFIG.maxStretch) * CONFIG.launchForce;
    
    Body.setVelocity(eggBody, {
        x: Math.cos(angle) * force,
        y: Math.sin(angle) * force
    });

    shake = 5;
}

// --- AI ---
async function initAI() {
    const model = await cocoSsd.load();
    document.getElementById('status-msg').innerText = "Drag Down to Fire";
    setInterval(async () => {
        if(!video || video.readyState !== 4) return;
        const preds = await model.detect(video);
        targets = preds.filter(p => p.class === 'person');
    }, 150);
}

// --- RENDER ---
function renderLoop() {
    requestAnimationFrame(renderLoop);
    Matter.Engine.update(engine, 1000/60);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Shake Effect
    if (shake > 0) {
        let sx = (Math.random() - 0.5) * shake;
        let sy = (Math.random() - 0.5) * shake;
        shake *= 0.9;
        ctx.save();
        ctx.translate(sx, sy);
    }

    drawParticles();

    if (isDragging) {
        drawBands(currentDrag.x, currentDrag.y);
        drawEgg(currentDrag.x, currentDrag.y, 20); 
        drawRectPouch(currentDrag.x, currentDrag.y);
    } 
    else if (eggBody) {
        if (eggBody.position.y > canvas.height + 200 || eggBody.position.x < -100 || eggBody.position.x > canvas.width + 100) {
            Matter.World.remove(world, eggBody);
            eggBody = null;
        } else {
            drawEgg(eggBody.position.x, eggBody.position.y, 15);
            checkHit();
        }
        // Draw relaxed bands while egg flies
        drawIdleBands();
    } else {
        drawIdleBands();
    }

    if (shake > 0) ctx.restore();
}

// --- VISUALS ---

function drawIdleBands() {
    const w = canvas.width;
    const h = canvas.height;
    const ay = h * CONFIG.anchorHeightRatio; // Anchor Y
    const hangY = h * 0.85; // How low it hangs

    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    
    // Draw "Drooping" Bands
    ctx.beginPath();
    // Left side -> Hang Point -> Right Side
    ctx.moveTo(0, ay);
    ctx.quadraticCurveTo(w * 0.2, hangY, w * 0.5, hangY);
    ctx.quadraticCurveTo(w * 0.8, hangY, w, ay);
    
    // Outer Dark
    ctx.lineWidth = 14;
    ctx.strokeStyle = "#3e2723"; 
    ctx.stroke();
    
    // Inner Light
    ctx.lineWidth = 6;
    ctx.strokeStyle = "#5d4037";
    ctx.stroke();

    // Pouch hanging at bottom
    drawRectPouch(w * 0.5, hangY);
}

function drawBands(eggX, eggY) {
    const w = canvas.width;
    const h = canvas.height;
    const ay = h * CONFIG.anchorHeightRatio;

    ctx.lineCap = "round";

    // Draw lines from Mid-Left/Right to Egg
    // Dark Outer
    ctx.strokeStyle = "#3e2723"; 
    ctx.lineWidth = 16;
    ctx.beginPath();
    ctx.moveTo(0, ay); ctx.lineTo(eggX, eggY);
    ctx.moveTo(w, ay); ctx.lineTo(eggX, eggY);
    ctx.stroke();

    // Light Inner
    ctx.strokeStyle = "#a1887f"; 
    ctx.lineWidth = 8;
    ctx.beginPath();
    ctx.moveTo(0, ay); ctx.lineTo(eggX, eggY);
    ctx.moveTo(w, ay); ctx.lineTo(eggX, eggY);
    ctx.stroke();
}

function drawRectPouch(x, y) {
    // Rectangular leather pouch
    ctx.save();
    ctx.translate(x, y);
    
    // Rotate slightly based on X position to look like it's pulling
    const rot = (x - window.innerWidth/2) * 0.002;
    ctx.rotate(rot);

    ctx.fillStyle = "#3e2723"; // Dark leather
    ctx.strokeStyle = "#271c19";
    ctx.lineWidth = 2;

    // Draw Rounded Rect manually
    const w = 50; 
    const h = 35;
    const r = 8;
    
    ctx.beginPath();
    ctx.moveTo(-w/2 + r, -h/2);
    ctx.lineTo(w/2 - r, -h/2);
    ctx.quadraticCurveTo(w/2, -h/2, w/2, -h/2 + r);
    ctx.lineTo(w/2, h/2 - r);
    ctx.quadraticCurveTo(w/2, h/2, w/2 - r, h/2);
    ctx.lineTo(-w/2 + r, h/2);
    ctx.quadraticCurveTo(-w/2, h/2, -w/2, h/2 - r);
    ctx.lineTo(-w/2, -h/2 + r);
    ctx.quadraticCurveTo(-w/2, -h/2, -w/2 + r, -h/2);
    ctx.closePath();
    
    ctx.fill();
    ctx.stroke();
    
    // Stitching details
    ctx.setLineDash([4, 4]);
    ctx.strokeStyle = "#d7ccc8";
    ctx.lineWidth = 1;
    ctx.stroke();
    
    ctx.restore();
}

function drawEgg(x, y, radius) {
    ctx.beginPath();
    ctx.ellipse(x, y, radius * 0.85, radius, eggBody ? eggBody.angle : 0, 0, Math.PI * 2);
    
    let grad = ctx.createRadialGradient(x - radius/3, y - radius/3, radius/4, x, y, radius);
    grad.addColorStop(0, "#fff");
    grad.addColorStop(1, "#ddd");
    
    ctx.fillStyle = grad;
    ctx.fill();
}

// --- PARTICLES ---
function createExplosion(x, y) {
    shake = CONFIG.shakeIntensity;
    score++;
    document.getElementById('score').innerText = score;
    for(let i=0; i<40; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 20,
            vy: (Math.random() - 0.5) * 20,
            radius: Math.random() * 8 + 3,
            color: Math.random() > 0.4 ? '#fdd835' : '#ffffff', 
            life: 1.0
        });
    }
}

function drawParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.fill();
        ctx.globalAlpha = 1.0;
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.5;
        p.life -= 0.015;
        if (p.life < 0.6) { p.vx *= 0.8; p.vy *= 0.8; }
        if (p.life <= 0) particles.splice(i, 1);
    }
}

function checkHit() {
    if (!eggBody) return;
    const sx = canvas.width / video.videoWidth;
    const sy = canvas.height / video.videoHeight;
    for (let t of targets) {
        let x = t.bbox[0] * sx;
        let y = t.bbox[1] * sy;
        let w = t.bbox[2] * sx;
        let h = t.bbox[3] * sy;
        if (eggBody.position.x > x && eggBody.position.x < x + w &&
            eggBody.position.y > y && eggBody.position.y < y + h) {
            createExplosion(eggBody.position.x, eggBody.position.y);
            Matter.World.remove(world, eggBody);
            eggBody = null;
            break;
        }
    }
}
</script>
</body>
</html>